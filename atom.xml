<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-08T13:38:53.394Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sliding window</title>
    <link href="http://example.com/2021/04/08/Sliding-window/"/>
    <id>http://example.com/2021/04/08/Sliding-window/</id>
    <published>2021-04-08T01:12:39.000Z</published>
    <updated>2021-04-08T13:38:53.394Z</updated>
    
    <content type="html"><![CDATA[<h1>Sliding Window Algorithm</h1><hr><p>Sliding window algorithm is a kind of two pointers. This algorithm mostly used in string match.</p><h2 id="template">template</h2><hr><pre><code>def slidingWindow(s, t):    need, window, valid = {}, {}, 0    left, right = 0, 0    while right &lt; len(s):        node = s[right]        right += 1        // update date        ...        while (window needs shrink):            deleteNode = s[left]            left += 1            // update data            ...</code></pre><h2 id="Notice">Notice</h2><hr><p>There are 4 questions need to be thought in sliding window algorithm</p><ol><li><p>When move <code>right</code> to expand window indicating add characters, which data need to update?</p></li><li><p>Under what conditions, the window should pause to expand, and start to move <code>left</code> to shrink the window?</p></li><li><p>When move <code>left</code>, which means delete characters, which data need to update?</p></li><li><p>Should the result we want be updated when the window is enlarged or when the window is reduced?</p></li></ol><h2 id="Example">Example</h2><hr><h3 id="leetcode-76-Minimum-Window-Substring-hard">leetcode 76 Minimum Window Substring (hard)</h3><h4 id="Description">Description</h4><p>Given two strings <code>s</code> and <code>t</code>, return the minimum window in <code>s</code> which will contain all the characters in <code>t</code>. If there is no such window in <code>s</code> that covers all characters in <code>t</code>, return the empty string <code>"".</code></p><p><strong>Note</strong> that If there is such a window, it is guaranteed that there will always be only one unique minimum window in <code>s</code>.</p><h4 id="Example-2">Example</h4><pre><code>Input: s = "ADOBECODEBANC", t = "ABC"Output: "BANC"</code></pre><h4 id="Code">Code</h4><pre><code>def minWindow(self, s, t):    need, window, valid, length = {}, {}, 0, float('inf')    for node in t:        if node not in need:            need[node] = 1        else:            need[node] += 1    left, right = 0, 0    while right &lt; len(s):        node = s[right]        right += 1        if node in need.keys():            if node not in window:                window[node] = 1            else:                window[node] += 1            if window[node] == need[node]:                valid += 1        while valid == len(need):            if right - left &lt; length:                start = left                length = right - left            deleteNode = s[left]            left += 1            if deleteNode in need.keys():                if window[deleteNode] == need[deleteNode]:                    valid -= 1                window[deleteNode] -= 1    return '' if length == float('inf') else s[start: start+length]</code></pre><h3 id="leetcode-567-Permutation-in-String-Medium">leetcode 567 Permutation in String (Medium)</h3><h4 id="Description-2">Description:</h4><p>Given two strings <strong>s1</strong> and <strong>s2</strong>, write a function to return true if <strong>s2</strong> contains the permutation of <strong>s1</strong>. In other words, one of the first string’s permutations is the <strong>substring</strong> of the second string.</p><h4 id="Example-3">Example</h4><pre><code>Input: s1 = "ab" s2 = "eidbaooo"Output: TrueExplanation: s2 contains one permutation of s1 ("ba").</code></pre><h4 id="Code-2">Code</h4><pre><code>def checkInclusion(self, s1, s2):    need, window, valid, = {}, {}, 0    for node in s1:        if node not in need:            need[node] = 1        else:            need[node] += 1    left, right = 0, 0    while right &lt; len(s2):        node = s2[right]        right += 1        if node in need.keys():            if node not in window:                window[node] = 1            else:                window[node] += 1            if window[node] == need[node]:                valid += 1        while right - left &gt;= len(s1):            if valid == len(need):                return True            deleteNode = s2[left]            left += 1            if deleteNode in need.keys():                if window[deleteNode] == need[deleteNode]:                    valid -= 1                window[deleteNode] -= 1    return False</code></pre><h3 id="leetcode-438-Find-All-Anagrams-in-a-String-Medium">leetcode 438 Find All Anagrams in a String (Medium)</h3><h4 id="Description-3">Description:</h4><p>Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s.</p><p>Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.</p><p>The order of output does not matter.</p><h4 id="Example-4">Example</h4><pre><code>Input:s: "cbaebabacd" p: "abc"Output:[0, 6]Explanation:The substring with start index = 0 is "cba", which is an anagram of "abc".The substring with start index = 6 is "bac", which is an anagram of "abc".</code></pre><h4 id="Code-3">Code</h4><pre><code>def findAnagrams(self, s, p):    need, window, valid, res = {}, {}, 0, []    for node in p:        if node not in need:            need[node] = 1        else:            need[node] += 1    left, right = 0, 0    while right &lt; len(s):        node = s[right]        right += 1        if node in need.keys():            if node not in window:                window[node] = 1            else:                window[node] += 1            if window[node] == need[node]:                valid += 1        while right - left &gt;= len(p):            if valid == len(need):                res.append(left)            deleteNode = s[left]            left += 1            if deleteNode in need.keys():                if window[deleteNode] == need[deleteNode]:                    valid -= 1                window[deleteNode] -= 1    return res</code></pre><h3 id="leetcode-3-Longest-Substring-Without-Repeating-Characters-Medium">leetcode 3 Longest Substring Without Repeating Characters (Medium)</h3><h4 id="Description-4">Description:</h4><p>Given a string s, find the length of the longest substring without repeating characters.</p><h4 id="Example-5">Example</h4><pre><code>Input: s = "abcabcbb"Output: 3Explanation: The answer is "abc", with the length of 3.</code></pre><h4 id="Code-4">Code</h4><pre><code>def lengthOfLongestSubstring(self, s):    if not s: return 0    left, right, res, window = 0, 0, 0, {}    while right &lt; len(s):        node = s[right]        right += 1        if node not in window:            window[node] = 1        else:            window[node] += 1        while window[node] &gt; 1:            deleteNode = s[left]            left += 1            window[deleteNode] -= 1        res = max(res, right - left)    return res</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Sliding Window Algorithm&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;Sliding window algorithm is a kind of two pointers. This algorithm mostly used in string match.&lt;/p</summary>
      
    
    
    
    <category term="Data structure and algorithm" scheme="http://example.com/categories/Data-structure-and-algorithm/"/>
    
    
    <category term="algorithm" scheme="http://example.com/tags/algorithm/"/>
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Heap and heapSort</title>
    <link href="http://example.com/2021/04/07/Heap-and-heapSort/"/>
    <id>http://example.com/2021/04/07/Heap-and-heapSort/</id>
    <published>2021-04-07T12:05:48.000Z</published>
    <updated>2021-04-09T02:06:33.772Z</updated>
    
    <content type="html"><![CDATA[<h1>Definition</h1><p>Heap is a kind of complete binary tree. A complete binary tree is a binary tree in which every level, except maybe last level, is full, and all nodes are as far as left as possible.</p><p>Commonly, there are two kinds of heap, the one is max-heap, and the other is min-heap.</p><p>Max-heap is the heap that parent’s value is greater than their children’s value, and the parent’s value of min-heap is less than their children.</p><h1>Operations</h1><h2 id="Insert-a-node">Insert a node</h2><ol><li><p>Make a new node in the last level, as far left as possible. If the last level is full, make a new one;</p></li><li><p>If the new one breaks heap property, swap with its parent node;</p></li><li><p>Repeat former two steps until every node is satisfied with heap property;</p></li><li><p>Time complexity <code>O(log H)</code> H is the height of tree</p></li></ol><h2 id="Delete-a-node">Delete a node</h2><ol><li><p>Remove the root node, and bring the last node (rightmost node in the last level) to the root;</p></li><li><p>If the root breaks heap property, look at its children and swap it with the larger one;</p></li><li><p>Repeat former two steps until no nodes conflict heap property;</p></li><li><p>Time complexity <code>O(log H)</code> H is the height of tree</p></li></ol><h1>Implement Max-heap with python</h1><pre><code>class MaxHeap:    def __init__(self, maxSize=None):        self.maxSize = maxSize        self.elements = []        self.count = 0    def addNode(self, value):        if self.count &gt; self.maxSize:            raise Exception('The heap is full.')        self.elements.append(value)        self.siftUp(self.count)        self.count += 1    def popNode(self):        if self.count == 0:            raise Exception('The heap is empty.')        value = self.elements[0]        self.count -= 1        self.elements[0] = self.elements[self.count]        self.siftDown(0)        return value    def siftUp(self, index):        if index &gt; 0:            parent = (index - 1) // 2            if self.elements[index] &gt; self.elements[parent]:                self.elements[index], self.elements[parent] = self.elements[parent], self.elements[index]                self.siftUp(parent)    def siftDown(self, index):        left = 2 * index + 1        right = 2 * index + 2        largest = index        if (left &lt;= self.count                and self.elements[left] &gt;= self.elements[largest]                and self.elements[left] &gt;= self.elements[right]):            largest = left        elif (right &lt; self.count              and self.elements[right] &gt;= self.elements[largest]):            largest = right        if largest != index:            self.elements[index], self.elements[largest] = self.elements[largest], self.elements[index]            self.siftDown(largest)</code></pre><h1>Heap sort</h1><p>From the above narrate, it is not hard to find no matter max-heap and min-heap, the top of heap is largest or least value of the whole heap, therefore, it</p><pre><code>    def heapSort(arr):      length = len(arr)      heap = MaxHeap(length)      for item in arr:        heap.addNode(item)      res = []      count = heap.count      while count &gt; 0:        node = heap.popNode()        res.insert(0, node)        count -= 1      return res</code></pre><p>Time complexity <code>O(N)</code> N is the length of array<br>Space complexity <code>O(N)</code> N is the length of array</p><p>Reference:</p><ol><li><p><a href="https://web.stanford.edu/class/cs97si/03-data-structures.pdf">https://web.stanford.edu/class/cs97si/03-data-structures.pdf</a></p></li><li><p><a href="https://python-data-structures-and-algorithms.readthedocs.io/zh/latest/15_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/heap_and_heapsort/">https://python-data-structures-and-algorithms.readthedocs.io/zh/latest/15_堆与堆排序/heap_and_heapsort/</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Definition&lt;/h1&gt;
&lt;p&gt;Heap is a kind of complete binary tree. A complete binary tree is a binary tree in which every level, except maybe la</summary>
      
    
    
    
    <category term="Data structure and algorithm" scheme="http://example.com/categories/Data-structure-and-algorithm/"/>
    
    
    <category term="Data structure" scheme="http://example.com/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>Stack and queue</title>
    <link href="http://example.com/2021/04/07/Stack-and-queue/"/>
    <id>http://example.com/2021/04/07/Stack-and-queue/</id>
    <published>2021-04-07T12:03:06.000Z</published>
    <updated>2021-04-09T02:06:33.779Z</updated>
    
    <content type="html"><![CDATA[<h1>Definition</h1><p><strong>Stack</strong>: Last in, first out (LIFO)</p><p><strong>Queue</strong>: First in, first out (FIFO)</p><h1>Operations</h1><h2 id="Stack">Stack</h2><ol><li><p>push(x): inserts x into a stack.</p></li><li><p>pop(): removes the newest item from a stack.</p></li><li><p>top(): returns the newest item from a stack.</p></li></ol><h2 id="Queue">Queue</h2><ol><li><p>Enqueue(x): inserts x into the queue.</p></li><li><p>Dequeue(): removes the oldest item from the queue.</p></li><li><p>Front(): returns the oldest item from the queue.</p></li></ol><h1>Implement with python</h1><h2 id="Stack-2">Stack</h2><pre><code>class Stack:    def __init__(self):        self.stack = []    def _push(self, value):        self.stack.append(value)    def _pop(self):        if not self.stack:            raise Exception('The stack is empty.')        return self.stack.pop()    def _top(self):        if not self.stack:            raise Exception('The stack is empty.')        return self.stack[-1]</code></pre><h2 id="Queue-2">Queue</h2><pre><code>class Queue:    def __init__(self):        self.queue = []    def enqueue(self, value):        self.queue.append(value)    def dequeue(self):        if not self.queue:            raise Exception('The queue is empty.')        return self.queue.pop(0)    def front(self):        if not self.queue:            raise Exception('The queue is empty.')        return self.queue[0]</code></pre><p>Reference:</p><ol><li><a href="https://web.stanford.edu/class/cs97si/03-data-structures.pdf">https://web.stanford.edu/class/cs97si/03-data-structures.pdf</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Definition&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Stack&lt;/strong&gt;: Last in, first out (LIFO)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Queue&lt;/strong&gt;: First in, first out (FIFO)&lt;/p&gt;
&lt;h1&gt;O</summary>
      
    
    
    
    <category term="Data structure and algorithm" scheme="http://example.com/categories/Data-structure-and-algorithm/"/>
    
    
    <category term="Data structure" scheme="http://example.com/tags/Data-structure/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Heap and heapSort</title>
      <link href="2021/04/07/Heap-and-heapSort/"/>
      <url>2021/04/07/Heap-and-heapSort/</url>
      
        <content type="html"><![CDATA[<h1 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h1><p>Heap is a kind of complete binary tree. A complete binary tree is a binary tree in which every level, except maybe last level, is full, and all nodes are as far as left as possible.</p><p>Commonly, there are two kinds of heap, the one is max-heap, and the other is min-heap.</p><p>Max-heap is the heap that parent’s value is greater than their children’s value, and the parent’s value of min-heap is less than their children.</p><h1 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h1><h2 id="Insert-a-node"><a href="#Insert-a-node" class="headerlink" title="Insert a node"></a>Insert a node</h2><ol><li><p>Make a new node in the last level, as far left as possible. If the last level is full, make a new one;</p></li><li><p>If the new one breaks heap property, swap with its parent node;</p></li><li><p>Repeat former two steps until every node is satisfied with heap property;</p></li><li><p>Time complexity <code>O(log H)</code> H is the height of tree</p></li></ol><h2 id="Delete-a-node"><a href="#Delete-a-node" class="headerlink" title="Delete a node"></a>Delete a node</h2><ol><li><p>Remove the root node, and bring the last node (rightmost node in the last level) to the root;</p></li><li><p>If the root breaks heap property, look at its children and swap it with the larger one;</p></li><li><p>Repeat former two steps until no nodes conflict heap property;</p></li><li><p>Time complexity <code>O(log H)</code> H is the height of tree</p></li></ol><h1 id="Implement-Max-heap-with-python"><a href="#Implement-Max-heap-with-python" class="headerlink" title="Implement Max-heap with python"></a>Implement Max-heap with python</h1><pre><code class="angular2html">class MaxHeap:    def __init__(self, maxSize=None):        self.maxSize = maxSize        self.elements = []        self.count = 0    def addNode(self, value):        if self.count &gt; self.maxSize:            raise Exception('The heap is full.')        self.elements.append(value)        self.siftUp(self.count)        self.count += 1    def popNode(self):        if self.count == 0:            raise Exception('The heap is empty.')        value = self.elements[0]        self.count -= 1        self.elements[0] = self.elements[self.count]        self.siftDown(0)        return value    def siftUp(self, index):        if index &gt; 0:            parent = (index - 1) // 2            if self.elements[index] &gt; self.elements[parent]:                self.elements[index], self.elements[parent] = self.elements[parent], self.elements[index]                self.siftUp(parent)    def siftDown(self, index):        left = 2 * index + 1        right = 2 * index + 2        largest = index        if (left &lt;= self.count                and self.elements[left] &gt;= self.elements[largest]                and self.elements[left] &gt;= self.elements[right]):            largest = left        elif (right &lt; self.count              and self.elements[right] &gt;= self.elements[largest]):            largest = right        if largest != index:            self.elements[index], self.elements[largest] = self.elements[largest], self.elements[index]            self.siftDown(largest)</code></pre><h1 id="Heap-sort"><a href="#Heap-sort" class="headerlink" title="Heap sort"></a>Heap sort</h1><p>From the above narrate, it is not hard to find no matter max-heap and min-heap, the top of heap is largest or least value of the whole heap, therefore, it</p><pre><code class="angular2html">    def heapSort(arr):      length = len(arr)      heap = MaxHeap(length)      for item in arr:        heap.addNode(item)      res = []      count = heap.count      while count &gt; 0:        node = heap.popNode()        res.insert(0, node)        count -= 1      return res</code></pre><p>Time complexity <code>O(N)</code> N is the length of array<br>Space complexity <code>O(N)</code> N is the length of array</p><p>Reference:</p><ol><li><p><a href="https://web.stanford.edu/class/cs97si/03-data-structures.pdf">https://web.stanford.edu/class/cs97si/03-data-structures.pdf</a></p></li><li><p><a href="https://python-data-structures-and-algorithms.readthedocs.io/zh/latest/15_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/heap_and_heapsort/">https://python-data-structures-and-algorithms.readthedocs.io/zh/latest/15_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/heap_and_heapsort/</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Data structure and algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack and queue</title>
      <link href="2021/04/07/Stack-and-queue/"/>
      <url>2021/04/07/Stack-and-queue/</url>
      
        <content type="html"><![CDATA[<h1 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h1><p><strong>Stack</strong>: Last in, first out (LIFO)</p><p><strong>Queue</strong>: First in, first out (FIFO)</p><h1 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h1><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><ol><li><p>push(x): inserts x into a stack.</p></li><li><p>pop(): removes the newest item from a stack.</p></li><li><p>top(): returns the newest item from a stack.</p></li></ol><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><ol><li><p>Enqueue(x): inserts x into the queue.</p></li><li><p>Dequeue(): removes the oldest item from the queue.</p></li><li><p>Front(): returns the oldest item from the queue.</p></li></ol><h1 id="Implement-with-python"><a href="#Implement-with-python" class="headerlink" title="Implement with python"></a>Implement with python</h1><h2 id="Stack-1"><a href="#Stack-1" class="headerlink" title="Stack"></a>Stack</h2><pre><code class="angular2html">class Stack:    def __init__(self):        self.stack = []    def _push(self, value):        self.stack.append(value)    def _pop(self):        if not self.stack:            raise Exception('The stack is empty.')        return self.stack.pop()    def _top(self):        if not self.stack:            raise Exception('The stack is empty.')        return self.stack[-1]</code></pre><h2 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h2><pre><code class="angular2html">class Queue:    def __init__(self):        self.queue = []    def enqueue(self, value):        self.queue.append(value)    def dequeue(self):        if not self.queue:            raise Exception('The queue is empty.')        return self.queue.pop(0)    def front(self):        if not self.queue:            raise Exception('The queue is empty.')        return self.queue[0]</code></pre><p>Reference:</p><ol><li><a href="https://web.stanford.edu/class/cs97si/03-data-structures.pdf">https://web.stanford.edu/class/cs97si/03-data-structures.pdf</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Data structure and algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

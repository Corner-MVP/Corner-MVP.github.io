<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Heap and heapSort</title>
      <link href="2021/04/07/Heap-and-heapSort/"/>
      <url>2021/04/07/Heap-and-heapSort/</url>
      
        <content type="html"><![CDATA[<h1 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h1><p>Heap is a kind of complete binary tree. A complete binary tree is a binary tree in which every level, except maybe last level, is full, and all nodes are as far as left as possible.</p><p>Commonly, there are two kinds of heap, the one is max-heap, and the other is min-heap.</p><p>Max-heap is the heap that parent’s value is greater than their children’s value, and the parent’s value of min-heap is less than their children.</p><h1 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h1><h2 id="Insert-a-node"><a href="#Insert-a-node" class="headerlink" title="Insert a node"></a>Insert a node</h2><ol><li><p>Make a new node in the last level, as far left as possible. If the last level is full, make a new one;</p></li><li><p>If the new one breaks heap property, swap with its parent node;</p></li><li><p>Repeat former two steps until every node is satisfied with heap property;</p></li><li><p>Time complexity <code>O(log H)</code> H is the height of tree</p></li></ol><h2 id="Delete-a-node"><a href="#Delete-a-node" class="headerlink" title="Delete a node"></a>Delete a node</h2><ol><li><p>Remove the root node, and bring the last node (rightmost node in the last level) to the root;</p></li><li><p>If the root breaks heap property, look at its children and swap it with the larger one;</p></li><li><p>Repeat former two steps until no nodes conflict heap property;</p></li><li><p>Time complexity <code>O(log H)</code> H is the height of tree</p></li></ol><h1 id="Implement-Max-heap-with-python"><a href="#Implement-Max-heap-with-python" class="headerlink" title="Implement Max-heap with python"></a>Implement Max-heap with python</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class MaxHeap:</span><br><span class="line">    def __init__(self, maxSize=None):</span><br><span class="line">        self.maxSize = maxSize</span><br><span class="line">        self.elements = []</span><br><span class="line">        self.count = 0</span><br><span class="line"></span><br><span class="line">    def addNode(self, value):</span><br><span class="line"></span><br><span class="line">        if self.count &gt; self.maxSize:</span><br><span class="line">            raise Exception('The heap is full.')</span><br><span class="line"></span><br><span class="line">        self.elements.append(value)</span><br><span class="line">        self.siftUp(self.count)</span><br><span class="line">        self.count += 1</span><br><span class="line"></span><br><span class="line">    def popNode(self):</span><br><span class="line"></span><br><span class="line">        if self.count == 0:</span><br><span class="line">            raise Exception('The heap is empty.')</span><br><span class="line"></span><br><span class="line">        value = self.elements[0]</span><br><span class="line">        self.count -= 1</span><br><span class="line">        self.elements[0] = self.elements[self.count]</span><br><span class="line">        self.siftDown(0)</span><br><span class="line">        return value</span><br><span class="line"></span><br><span class="line">    def siftUp(self, index):</span><br><span class="line"></span><br><span class="line">        if index &gt; 0:</span><br><span class="line">            parent = (index - 1) // 2</span><br><span class="line">            if self.elements[index] &gt; self.elements[parent]:</span><br><span class="line">                self.elements[index], self.elements[parent] = self.elements[parent], self.elements[index]</span><br><span class="line">                self.siftUp(parent)</span><br><span class="line"></span><br><span class="line">    def siftDown(self, index):</span><br><span class="line"></span><br><span class="line">        left = 2 * index + 1</span><br><span class="line">        right = 2 * index + 2</span><br><span class="line">        largest = index</span><br><span class="line">        if (left &lt;= self.count</span><br><span class="line">                and self.elements[left] &gt;= self.elements[largest]</span><br><span class="line">                and self.elements[left] &gt;= self.elements[right]):</span><br><span class="line">            largest = left</span><br><span class="line"></span><br><span class="line">        elif (right &lt; self.count</span><br><span class="line">              and self.elements[right] &gt;= self.elements[largest]):</span><br><span class="line">            largest = right</span><br><span class="line"></span><br><span class="line">        if largest != index:</span><br><span class="line">            self.elements[index], self.elements[largest] = self.elements[largest], self.elements[index]</span><br><span class="line">            self.siftDown(largest)</span><br></pre></td></tr></tbody></table></figure><h1 id="Heap-sort"><a href="#Heap-sort" class="headerlink" title="Heap sort"></a>Heap sort</h1><p>From the above narrate, it is not hard to find no matter max-heap and min-heap, the top of heap is largest or least value of the whole heap, therefore, it</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def heapSort(arr):</span><br><span class="line"></span><br><span class="line">  length = len(arr)</span><br><span class="line">  heap = MaxHeap(length)</span><br><span class="line"></span><br><span class="line">  for item in arr:</span><br><span class="line">    heap.addNode(item)</span><br><span class="line"></span><br><span class="line">  res = []</span><br><span class="line">  count = heap.count</span><br><span class="line">  while count &gt; 0:</span><br><span class="line">    node = heap.popNode()</span><br><span class="line">    res.insert(0, node)</span><br><span class="line">    count -= 1</span><br><span class="line"></span><br><span class="line">  return res</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>Time complexity <code>O(N)</code> N is the length of array<br>Space complexity <code>O(N)</code> N is the length of array</p><p>Reference:</p><ol><li><p><a href="https://web.stanford.edu/class/cs97si/03-data-structures.pdf">https://web.stanford.edu/class/cs97si/03-data-structures.pdf</a></p></li><li><p><a href="https://python-data-structures-and-algorithms.readthedocs.io/zh/latest/15_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/heap_and_heapsort/">https://python-data-structures-and-algorithms.readthedocs.io/zh/latest/15_%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/heap_and_heapsort/</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Data structure and algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack and queue</title>
      <link href="2021/04/07/Stack-and-queue/"/>
      <url>2021/04/07/Stack-and-queue/</url>
      
        <content type="html"><![CDATA[<h1 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h1><p><strong>Stack</strong>: Last in, first out (LIFO)</p><p><strong>Queue</strong>: First in, first out (FIFO)</p><h1 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h1><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><ol><li><p>push(x): inserts x into a stack.</p></li><li><p>pop(): removes the newest item from a stack.</p></li><li><p>top(): returns the newest item from a stack.</p></li></ol><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><ol><li><p>Enqueue(x): inserts x into the queue.</p></li><li><p>Dequeue(): removes the oldest item from the queue.</p></li><li><p>Front(): returns the oldest item from the queue.</p></li></ol><h1 id="Implement-with-python"><a href="#Implement-with-python" class="headerlink" title="Implement with python"></a>Implement with python</h1><h2 id="Stack-1"><a href="#Stack-1" class="headerlink" title="Stack"></a>Stack</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Stack:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    def _push(self, value):</span><br><span class="line">        self.stack.append(value)</span><br><span class="line"></span><br><span class="line">    def _pop(self):</span><br><span class="line"></span><br><span class="line">        if not self.stack:</span><br><span class="line">            raise Exception('The stack is empty.')</span><br><span class="line">        return self.stack.pop()</span><br><span class="line"></span><br><span class="line">    def _top(self):</span><br><span class="line"></span><br><span class="line">        if not self.stack:</span><br><span class="line">            raise Exception('The stack is empty.')</span><br><span class="line">        return self.stack[-1]</span><br></pre></td></tr></tbody></table></figure><h2 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Queue:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.queue = []</span><br><span class="line"></span><br><span class="line">    def enqueue(self, value):</span><br><span class="line">        self.queue.append(value)</span><br><span class="line"></span><br><span class="line">    def dequeue(self):</span><br><span class="line"></span><br><span class="line">        if not self.queue:</span><br><span class="line">            raise Exception('The queue is empty.')</span><br><span class="line">        return self.queue.pop(0)</span><br><span class="line"></span><br><span class="line">    def front(self):</span><br><span class="line">        if not self.queue:</span><br><span class="line">            raise Exception('The queue is empty.')</span><br><span class="line">        return self.queue[0]</span><br></pre></td></tr></tbody></table></figure><p>Reference:</p><ol><li><a href="https://web.stanford.edu/class/cs97si/03-data-structures.pdf">https://web.stanford.edu/class/cs97si/03-data-structures.pdf</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Data structure and algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
